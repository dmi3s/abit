# Calculator
## Задание

Напишите программу калькулятора, который вычисляет значение выражения, заданного на очень простом языке целочисленных вычислений. Программа должна принимать выражение в качестве аргумента, вычислять значение выражения и печатать результат на консоль.

Пример:
```bash
$ calculator.exe "mult(2, 2)"
4
```
Ещё примеры выражений:

Ввод | Вывод
-----|------
`add(1, 2)` | `3`
`add(1, mult(2, 3))` | `7`
`mult(add(2, 2), div(9, 3))` | `12`
`let(a, 5, add(a, a))`|`10`
`let(a, 5, let(b, mult(a, 10), add(b, a)))`|`55`
`let(a, let(b, 10, add(b, b)), let(b, 20, add(a, b)))`|`40`

Состав выражения:
* Числа:
 **целые числа** в диапазоне `[numeric_limits<int>::min(), numeric_limits<int>::max()]`
* Переменные: 
 **строки символов**, символ из диапазона `[a-z, A-Z]`
* Арифметические функции: `add()`, `sub()`, `mult()`, `div()`.<br/> 
Каждая функция принимает два произвольных выражения в качестве аргументов. Другими словами, любой из аргументов может быть произвольным выражением из данного списка.
* Оператор `let` для присваивания значений переменным:
`let(<variable name>, <value>, <expression where variable is used>)`.<br/>
Так же, как и в случае с арифметическими функциями, выражение, где используется переменная, может быть **произвольным выражением** из данного списка.

Пожалуйста, отправьте то, что вы считаете *__тестируемым и поддерживаемым промышленным кодом__*.  Если формулировка задачи неясна, делайте предположения, но, пожалуйста, укажите свои предположения в комментариях к решению.

## Решение ##
### Предположения по формулировке ###
* Области видимости переменных (scopes) могут быть вложенными, новое значени переменной действует только внутри оператора `let()`. 
* Имена переменных могут совпадать с именами функций, т.е. выражение `let(div, 20, div(div,10))` считается корректным и д.б. вычислено как `2`.
* Пустое выражение не вычислимо, программа выведет сообщение об ошибке.
* Сообщения об ошибках парсинга или деления на ноль должны обрабатываться. В идеале - точно показывать место ошибки.
### API решения ###
Главная функция программы объявлена в файле `src/interpret.hpp` как
```cpp
    optional<int> interpret(
        string::const_iterator begin,
        string::const_iterator end, 
        ostream& errors_stream);
```
Собственно, она пытается интерпретировать инструкции в интервале `[begin,end)` и вернуть вычесленный результат. В случае ошибки, текстовые сообщения пишутся в `errors_stream`.
Примеры использования можно увидеть в файлах тестов `tests/src/interpret_*.cpp`.
### Особенности реализации ###
"Под капотом" парсинга скрыто использование `boost::spirit`. <br/>
Сама грамматика языка описана в файле `src/calculator_grammar.hpp`. <br/>
Работа с вложенными областями видимости реализована крайне примитивно, зато интерфейс состоит всего из 3х фунций, и реализацию в дальнейшем можно оптимизировать под конкретные условия использования. Класс таблицы символов описан в файле `src/symbol_table.hpp`, тесты использования - в файле `tests/src/symtable_tests.cpp`.
### Сборка проекта ###
* Prerequirements:
    * cmake 3.9 
    * boost 1.65
    * Visual Studio 2012+ (сам собирал под VS 2017, так что не уверен, что на старых соберется. На VS 2015 должна)
* Получение исходников и сборка:
```bash
$git clone git@github.com:dmi3s/abit.git
$cd abit
$mkdir mbuild && cd mbuild
$cmake ..
# на этом этапе в каталоге mbuild уже есть файл abit-test.sln, который можно
# открыть в VS, и дальше собирать уже студией.
# либо же собрать cmake-ом.
$cmake --build .
# По умолчанию cmake собирает Debug конфигурацию, поэтому все выполняемые файлы
# проекта лежат в каталоге mbuild/Debug. 
# А именно:
# calculator.exe - собственно, само приложение
# symtable_tests.exe - тесты таблицы символов
# interpret_tests.exe - тесты интерпретатораю
```
### Замечания по тестам ###
